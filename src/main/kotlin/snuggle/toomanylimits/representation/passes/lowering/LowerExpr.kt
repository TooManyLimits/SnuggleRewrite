package snuggle.toomanylimits.representation.passes.lowering

import org.objectweb.asm.Label
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes
import snuggle.toomanylimits.builtins.primitive.*
import snuggle.toomanylimits.representation.asts.ir.GeneratedType
import snuggle.toomanylimits.representation.asts.ir.Instruction
import snuggle.toomanylimits.representation.asts.typed.FieldDef
import snuggle.toomanylimits.representation.asts.typed.MethodDef
import snuggle.toomanylimits.representation.asts.typed.TypeDef
import snuggle.toomanylimits.representation.asts.typed.TypedExpr
import snuggle.toomanylimits.util.Cons
import snuggle.toomanylimits.util.ConsList
import snuggle.toomanylimits.util.caching.EqualityIncrementalCalculator

/**
 * Lowering an expression into IR.
 *
 * @param desiredFields is a concept related to the implementation of fields of plural types.
 *
 * If you have a plural type, like a tuple, stored as a local variable, the implementation
 * in the runtime is to instead have multiple local variables, one for each element
 * of the tuple. (This recurses if an element of the tuple is also a plural type).
 * Say, for instance, you have a field-get expression ((x).y).z, where x is a local variable
 * with plural type, y is a field of x that has a plural type, and z is a field of that
 * plural type. The progression of the calls would be as follows:
 * - lowerExpr "((x).y).z", desiredFields = []
 * - lowerExpr "(x).y", desiredFields = ["z"]
 * - lowerExpr "x", desiredFields = ["y", "z"]
 * Then, the handler for "local variable" (which is what x is) will take
 * the desired fields into account, and select the correct backing field.
 * In short:
 * DesiredFields are generated by Field* expressions, and consumed by other expressions.
 *
 * Addition: DesiredFields can now be passed "through" bytecode method calls, to their
 * receivers. Also, desired fields can be a list of multiple cons lists. The reason is
 * that certain operations may want multiple discontiguous groups of desired fields.
 * For example, take an Option<Vec3>, and you call .get().y on it. The `.get()` bytecode
 * method call will pass along the desired field ["y"], as well as the other desired field
 * ["isPresent"]. (Ignoring the fields x and z).
 *
 * The length of desiredFields should always be at least 1.
 *
 * @param filesWithEffects tells us which files have effects when imported, and which don't.
 * This can be used to not emit any instruction for an import of said file, useful for making
 * files which only provide definitions not consume instructions when imported. Only used by the
 * TypedExpr.Import expression.
 *
 */

// I hope these "sequence {}" blocks aren't slow since they're really convenient
fun lowerExpr(expr: TypedExpr, desiredFields: ConsList<ConsList<FieldDef>>, filesWithEffects: Set<String>, typeCalc: EqualityIncrementalCalculator<TypeDef, GeneratedType>): Sequence<Instruction> = when (expr) {
    // Run the import if the file has effects
    is TypedExpr.Import -> if (filesWithEffects.contains(expr.file))
        sequenceOf(Instruction.RunImport(expr.file))
    else sequenceOf()
    // Sequence the operations inside the block
    is TypedExpr.Block -> sequence {
        for (i in 0 until expr.exprs.size - 1) {
            yieldAll(lowerExpr(expr.exprs[i], ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
            yield(Instruction.Pop(expr.exprs[i].type))
        }
        yieldAll(lowerExpr(expr.exprs.last(), desiredFields, filesWithEffects, typeCalc))
    }
    // What to do for a declaration depends on the type of pattern
    is TypedExpr.Declaration -> sequence {
        // Push the initializer
        yieldAll(lowerExpr(expr.initializer, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        // Apply the pattern
        yieldAll(storeInfalliblePattern(expr.pattern, filesWithEffects, typeCalc))
    }

    // Extracted to special method, since it's complex
    is TypedExpr.Assignment -> handleAssignment(expr.lhs, expr.rhs, ConsList.nil(), expr.maxVariable, filesWithEffects, typeCalc)

    // Load the local variable
    is TypedExpr.Variable -> sequence {
        for (fieldGroup in desiredFields) {
            val wantedType = fieldGroup.lastOrNull()?.type ?: expr.type
            var startIndex = expr.variableIndex + getPluralOffset(fieldGroup)
            if (wantedType.isPlural) {
                for ((_, field) in wantedType.recursivePluralFields) {
                    yield(Instruction.LoadLocal(startIndex, field.type))
                    startIndex += field.type.stackSlots
                }
            } else {
                yield(Instruction.LoadLocal(startIndex, wantedType))
            }
        }
    }

    // Push the literal
    is TypedExpr.Literal -> sequenceOf(Instruction.Push(expr.value, expr.type))

    is TypedExpr.FieldAccess -> sequence {
        if (expr.receiver.type.isReferenceType) {
            // If the receiver is a reference type, then
            // we don't need to pass the fields further down.
            // Instead, we handle them all here.
            // Compile the receiver: (which yields a reference type on the stack)
            yieldAll(lowerExpr(expr.receiver, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
            val numberOfGroups = desiredFields.count()
            // If there are multiple fields groups, or if any particular field group is plural with > 1 elem,
            // need to store the receiver as a local variable.
            val neededToStoreLocal = numberOfGroups > 1 || desiredFields.any {
                val lastField = it.lastOrNull() ?: expr.fieldDef
                lastField.type.isPlural && lastField.type.recursivePluralFields.size > 1
            }
            if (neededToStoreLocal)
                yield(Instruction.StoreLocal(expr.maxVariable, expr.receiver.type))
            for (fieldGroup in desiredFields) {
                // Now, we follow back up the list of desired fields.
                val namePrefix = fieldGroup.fold(expr.fieldName) {prefix, field -> prefix + "$" + field.name}
                // If the last field in the chain is plural, then we need multiple operations; otherwise just one.
                val lastField = fieldGroup.lastOrNull() ?: expr.fieldDef
                if (lastField.type.isPlural) {
                    // If the last field in the chain is plural, store the reference type
                    // as a top local variable, then repeatedly grab it and GetReferenceTypeField.
                    for ((pathToField, field) in lastField.type.recursivePluralFields) {
                        if (neededToStoreLocal)
                            yield(Instruction.LoadLocal(expr.maxVariable, expr.receiver.type))
                        yield(Instruction.GetReferenceTypeField(expr.receiver.type, field.type, namePrefix + "$" + pathToField))
                    }
                } else {
                    // If not, then simply grab the field with the name prefix.
                    if (neededToStoreLocal)
                        yield(Instruction.LoadLocal(expr.maxVariable, expr.receiver.type))
                    yield(Instruction.GetReferenceTypeField(expr.receiver.type, lastField.type, namePrefix))
                }
            }
        } else if (expr.receiver.type.isPlural) {
            // Otherwise, if the receiver is not a reference type,
            // but is instead plural, we will pass the problem
            // down a level, by consing a new field def onto each
            // desired field group.
            yieldAll(lowerExpr(expr.receiver, desiredFields.map { Cons(expr.fieldDef, it) }, filesWithEffects, typeCalc))
        } else {
            // Any type that has accessible fields should either be a reference
            // type, or plural. This is a bug!
            throw IllegalStateException("Types with accessible fields should be either reference types or plural - " +
                    "but type \"${expr.receiver.type.name}\" is neither! Whoever implemented this type has made " +
                    "a mistake. Please contact them!")
        }
    }
    is TypedExpr.StaticFieldAccess -> sequence {
        for (fieldGroup in desiredFields) {
            // Similar code to the "if reference type" branch of the regular field access.
            val namePrefix = fieldGroup.fold(expr.fieldName) {prefix, field -> prefix + "$" + field.name}
            val lastField = fieldGroup.lastOrNull() ?: expr.fieldDef
            if (lastField.type.isPlural) {
                for ((pathToField, field) in lastField.type.recursivePluralFields)
                    yield(Instruction.GetStaticField(expr.receiverType, field.type, namePrefix + "$" + pathToField))
            } else {
                yield(Instruction.GetStaticField(expr.receiverType, lastField.type, lastField.name))
            }
        }
    }

    // Compile arguments, make call
    is TypedExpr.MethodCall -> sequence {
        lowerTypeDef(expr.methodDef.owningType, filesWithEffects, typeCalc)

        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        val receiverDesiredFields = if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.desiredReceiverFields != null)
                expr.methodDef.desiredReceiverFields!!(desiredFields)
            else ConsList.of(ConsList.nil())

        yieldAll(lowerExpr(expr.receiver, receiverDesiredFields, filesWithEffects, typeCalc))
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        if (expr.methodDef.owningType.unwrap() is TypeDef.ClassDef)
            yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Virtual(it) })
        else
            yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Static(it) })
    }
    is TypedExpr.StaticMethodCall -> sequence {
        lowerTypeDef(expr.receiverType, filesWithEffects, typeCalc)
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Static(it) })
    }
    is TypedExpr.SuperMethodCall -> sequence {
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        // Load "this" on the stack
        yield(Instruction.LoadRefType(expr.thisVariableIndex))
        // Push args
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        // Create call
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Special(it) })
    }
    is TypedExpr.ClassConstructorCall -> sequence {
        lowerTypeDef(expr.type, filesWithEffects, typeCalc)
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        // Push and dup the receiver
        yield(Instruction.NewRefAndDup(expr.type))
        // Push args
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Special(it) })
    }
    is TypedExpr.RawStructConstructor -> sequence {
        var curFieldGroup = (desiredFields as Cons).elem
        for ((field, value) in expr.type.nonStaticFields.zip(expr.fieldValues)) {
            if (curFieldGroup is Cons && curFieldGroup.elem == field) {
                // We desire this field group specifically, so lower it
                yieldAll(lowerExpr(value, ConsList.of(curFieldGroup.rest), filesWithEffects, typeCalc))
                // Advance to next field group
                curFieldGroup = curFieldGroup.rest
            } else {
                // Yield the field value
                yieldAll(lowerExpr(value, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
                // If we desire something specific, but this is not it, then pop the value
                if (curFieldGroup is Cons)
                    yield(Instruction.Pop(value.type))
            }
        }
        if (!curFieldGroup.isEmpty())
            throw IllegalStateException("Cur field group should be nil here - bug in compiler, please report")
    }

    is TypedExpr.Return -> sequence {
        // Yield the RHS, pushing it on the stack
        yieldAll(lowerExpr(expr.rhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        val returnType = expr.rhs.type
        // If it's plural, decompose into static field writes and one return.
        if (returnType.isPlural) {
            // Empty plural type: Just return void (null)
            if (returnType.recursivePluralFields.isEmpty())
                yield(Instruction.Return(null))
            else {
                // The code here closely mirrors the code for getMethodResults.
                // This is where the static fields are STORED, and in getMethodResults,
                // they're READ.
                val namePrefix = "RETURN! "
                returnType.recursivePluralFields.asReversed().dropLast(1).forEach { (pathToField, field) ->
                    // Put all except the first into static fields.
                    yield(Instruction.PutStaticField(returnType, field.type, namePrefix + "$" + pathToField))
                }
                // Return the last.
                yield(Instruction.Return(returnType.recursivePluralFields.first().second.type))
            }
        } else {
            // If return type is not plural, just return normally.
            yield(Instruction.Return(returnType))
        }
    }

    is TypedExpr.If -> {
        val ifFalseLabel = Label()
        val doneLabel = Label()
        sequence {
            // Cond, jump if false to false branch
            yieldAll(lowerExpr(expr.cond, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
            yield(Instruction.JumpIfFalse(ifFalseLabel))
            // True branch
            val loweredTrueBranch = lowerExpr(expr.ifTrue, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc)
            yield(Instruction.CodeBlock(loweredTrueBranch.toList()))
            yield(Instruction.Jump(doneLabel))
            // False branch
            yield(Instruction.IrLabel(ifFalseLabel))
            val loweredFalseBranch = lowerExpr(expr.ifFalse, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc)
            yield(Instruction.CodeBlock(loweredFalseBranch.toList()))
            // Done
            yield(Instruction.IrLabel(doneLabel))
        }
    }

    is TypedExpr.While -> {
        val condLabel = Label()
        val doneLabel = Label()
        sequence {
            // Cond label
            yield(Instruction.IrLabel(condLabel))
            // Yield the lowered cond + jump as its own code block
            val loweredCond = sequence {
                yieldAll(lowerExpr(expr.cond, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
                yield(Instruction.JumpIfFalse(doneLabel))
            }
            yield(Instruction.CodeBlock(loweredCond.toList()))
            // Yield the lowered body + jump as its own code block
            val loweredBody = sequence {
                yieldAll(lowerExpr(expr.body, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc)) // Eval body
                yield(Instruction.Pop(expr.body.type)) // Pop output
                yield(Instruction.Jump(condLabel)) // Jump back to evaluate cond again
            }
            yield(Instruction.CodeBlock(loweredBody.toList()))
            // Done label
            yield(Instruction.IrLabel(doneLabel))
        }
    }

    is TypedExpr.Is -> sequence {
        // Lower the LHS
        yieldAll(lowerExpr(expr.lhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        // Test the pattern
        yieldAll(testFalliblePattern(expr.pattern, filesWithEffects, typeCalc))
    }

    is TypedExpr.As -> sequence {
        // Lower the LHS
        yieldAll(lowerExpr(expr.lhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        // Do the cast
        yieldAll(handleCast(expr.forced, expr.lhs.type, expr.type))
    }

}

private fun getPluralOffset(fieldsToFollow: ConsList<FieldDef>): Int = fieldsToFollow.sumOf { it.pluralOffset!! }

private inline fun createCall(
    methodDef: MethodDef, desiredFields: ConsList<ConsList<FieldDef>>,
    maxVariable: Int,
    crossinline snuggleCallType: (MethodDef.SnuggleMethodDef) -> Instruction.MethodCall
): Sequence<Instruction> = sequence {
    when (methodDef) {
        is MethodDef.BytecodeMethodDef -> yield(Instruction.Bytecodes(0) { methodDef.bytecode(it, maxVariable, desiredFields) }) //TODO: Cost
        is MethodDef.InterfaceMethodDef -> yield(Instruction.MethodCall.Interface(methodDef))
        is MethodDef.CustomMethodDef -> yieldAll(methodDef.lowerer())
        // Invoke according to the snuggle call type
        is MethodDef.SnuggleMethodDef -> {
            if (methodDef.staticOverrideReceiverType != null) // Static override - always call this method statically
                yield(Instruction.MethodCall.Static(methodDef))
            else
                yield(snuggleCallType(methodDef))
        }
        is MethodDef.ConstMethodDef,
        is MethodDef.StaticConstMethodDef -> throw IllegalStateException("Cannot lower const method call - bug in compiler, please report")
        is MethodDef.GenericMethodDef<*> -> throw IllegalStateException("Cannot lower generic method call - bug in compiler, please report")
    }
    if (methodDef !is MethodDef.BytecodeMethodDef)
        yieldAll(getMethodResults(methodDef, desiredFields))
}

/**
 * This handles fetching method results after a method call is made.
 * In most cases, the return is just a single value, and this doesn't
 * need to do anything.
 *
 * However, when the return value is a plural type with more than 1
 * element, this will need to grab most of them out of their static variables in the end.
 */
private fun getMethodResults(methodToCall: MethodDef, desiredFields: ConsList<ConsList<FieldDef>>): Sequence<Instruction> {
    return if (methodToCall.returnType.isPlural && methodToCall.returnType.recursivePluralFields.size > 1) sequence {

        // Grab the first recursive plural field in the return type
        val firstField = methodToCall.returnType.recursivePluralFields[0].second
        // Helper function to check if a field group contains the first field
        fun containsFirstField(fieldGroup: ConsList<FieldDef>): Boolean {
            val lastOrNull = fieldGroup.lastOrNull()
            // If the last field desired is this firstField, return true
            if (lastOrNull === firstField)
                return true
            // Otherwise, see if the last desired type contains the first field
            val lastDesiredType = lastOrNull?.type ?: methodToCall.returnType
            return lastDesiredType.isPlural && lastDesiredType.recursivePluralFields[0].second === firstField
        }
        // If the first of the recursive plural fields is desired, then don't pop it.
        val firstFieldDesired = desiredFields.any { containsFirstField(it) }
        if (!firstFieldDesired)
            yield(Instruction.Pop(firstField.type))

        // Now, go through the rest of the fields. Any that are desired should have a GETSTATIC emitted.
        for (fieldGroup in desiredFields) {
            val namePrefix = fieldGroup.fold("RETURN! ") {prefix, field -> prefix + "$" + field.name}
            val lastDesiredType = fieldGroup.lastOrNull()?.type ?: methodToCall.returnType
            if (lastDesiredType.isPlural) {
                // If this group contains the first field, we already dealt with that, so ignore. Note the .drop(1).
                if (containsFirstField(fieldGroup))
                    lastDesiredType.recursivePluralFields.asSequence().drop(1).forEach { (pathToField, field) ->
                        yield(Instruction.GetStaticField(methodToCall.returnType, field.type, namePrefix + "$" + pathToField))
                    }
                else // Otherwise, don't drop 1.
                    lastDesiredType.recursivePluralFields.forEach { (pathToField, field) ->
                        yield(Instruction.GetStaticField(methodToCall.returnType, field.type, namePrefix + "$" + pathToField))
                    }
            } else {
                // If the last type was not plural... check if the field group contains the first field:
                if (containsFirstField(fieldGroup)) {
                    // If it did, do nothing! The first field was already fetched.
                } else {
                    // Otherwise, fetch it:
                    yield(Instruction.GetStaticField(methodToCall.returnType, lastDesiredType, namePrefix))
                }
            }
        }
    } else sequenceOf()
}

/**
 * Handle assignment to an lvalue, recursively (plural field accesses, etc)
 *
 * fieldsToFollow starts as nil.
 * assignmentType is the type being assigned to the lvalue.
 */
private fun handleAssignment(lhs: TypedExpr, rhs: TypedExpr, fieldsToFollow: ConsList<FieldDef>, maxVariable: Int, filesWithEffects: Set<String>, typeCalc: EqualityIncrementalCalculator<TypeDef, GeneratedType>): Sequence<Instruction> = when {
    lhs is TypedExpr.Variable -> sequence {
        yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        val startIndex = lhs.variableIndex + getPluralOffset(fieldsToFollow)
        if (rhs.type.isPlural) {
            var curIndex = startIndex + rhs.type.stackSlots
            for ((_, field) in rhs.type.recursivePluralFields.asReversed()) {
                curIndex -= field.type.stackSlots
                yield(Instruction.StoreLocal(curIndex, field.type))
            }
        } else {
            yield(Instruction.StoreLocal(startIndex, rhs.type))
        }
    }

    lhs is TypedExpr.StaticFieldAccess -> sequence {
        yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        val namePrefix = fieldsToFollow.fold(lhs.fieldName) { prefix, field -> prefix + "$" + field.name }
        if (rhs.type.isPlural) {
            for ((pathToField, field) in rhs.type.recursivePluralFields.asReversed())
                yield(Instruction.PutStaticField(lhs.receiverType, field.type, namePrefix + "$" + pathToField))
        } else {
            yield(Instruction.PutStaticField(lhs.receiverType, rhs.type, lhs.fieldName))
        }
    }

    lhs is TypedExpr.FieldAccess && lhs.receiver.type.isReferenceType -> sequence {
        yieldAll(lowerExpr(lhs.receiver, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
        val namePrefix = fieldsToFollow.fold(lhs.fieldName) { prefix, field -> prefix + "$" + field.name }
        //TODO: Use a "neededToStore" like above to avoid storing as local for 1-elem structs
        if (rhs.type.isPlural) {
            // Store the reference type as a local, to grab later
            yield(Instruction.StoreLocal(maxVariable, lhs.receiver.type))
            // Emit the RHS onto the stack
            yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
            // For each field, store it
            for ((pathToField, field) in rhs.type.recursivePluralFields.asReversed()) {
                yield(Instruction.LoadLocal(maxVariable, lhs.receiver.type))
                yield(Instruction.SwapBasic(lhs.receiver.type, field.type))
                yield(Instruction.PutReferenceTypeField(lhs.receiver.type, field.type, namePrefix + "$" + pathToField))
            }
        } else {
            // Just set the field directly
            yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), filesWithEffects, typeCalc))
            yield(Instruction.PutReferenceTypeField(lhs.receiver.type, rhs.type, namePrefix))
        }
    }

    // Recursive case: The LHS is a field access, but its receiver is not a reference type.
    lhs is TypedExpr.FieldAccess -> handleAssignment(lhs.receiver, rhs, Cons(lhs.fieldDef, fieldsToFollow), maxVariable, filesWithEffects, typeCalc)

    else -> throw IllegalStateException("Illegal assignment case - bug in compiler, please report")
}

// The value to be cast starts on the top of the stack.
private fun handleCast(forced: Boolean, from: TypeDef, to: TypeDef): Sequence<Instruction> {
    // Helper
    fun isJvmPrimitive(type: TypeDef) = type.builtin is IntType || type.builtin is FloatType || type.builtin === BoolType

    return sequence {
        // If this cast is checked, then check it:
        if (!forced) {
            TODO("Checked casts not yet implemented, use \"as!\" instead of \"as\" for unchecked casts.")
        }
        
        yieldAll(when {
            isJvmPrimitive(from) && isJvmPrimitive(to) -> {
                // Convert BoolType to BoolIntType to reduce the amount of logic needed
                val from = if (from.builtin === BoolType) U1Type else from.builtin
                val to = if (to.builtin === BoolType) U1Type else to.builtin

                fun bytecode(func: (MethodVisitor) -> Unit) = sequenceOf(Instruction.Bytecodes(1, func))
                fun bitmask(writer: MethodVisitor, mask: Long) {
                    if (mask == 0xFFFFL)
                        writer.visitInsn(Opcodes.I2C)
                    else {
                        when (mask) {
                            1L -> writer.visitInsn(Opcodes.ICONST_1)
                            0xFFL -> writer.visitIntInsn(Opcodes.SIPUSH, 0xFF)
                            0xFFFFFFFFL -> writer.visitLdcInsn(0xFFFFFFFFL)
                            else -> throw IllegalStateException()
                        }
                        if (mask == 0xFFFFFFFFL)
                            writer.visitInsn(Opcodes.LAND)
                        else
                            writer.visitInsn(Opcodes.IAND)
                    }
                }

                when (from) {
                    U1Type -> when (to) {
                        U1Type, I8Type, U8Type, I16Type, U16Type, CharType, I32Type, U32Type -> sequenceOf()
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    I8Type -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        U8Type -> bytecode { bitmask(it, 0xFF) }
                        I8Type, I16Type, I32Type, U32Type -> sequenceOf()
                        U16Type, CharType -> bytecode { bitmask(it, 0xFFFF) }
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    U8Type -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.I2B) }
                        U8Type, I16Type, U16Type, CharType, I32Type, U32Type -> sequenceOf()
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    I16Type -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { bitmask(it, 0xFF) }
                        I16Type, I32Type, U32Type -> sequenceOf()
                        U16Type, CharType -> bytecode { bitmask(it, 0xFFFF) }
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    U16Type, CharType -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType, I32Type, U32Type -> sequenceOf()
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    I32Type -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { bitmask(it, 0xFFFF) }
                        U32Type -> sequenceOf()
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    U32Type -> when (to) {
                        U1Type -> bytecode { bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { bitmask(it, 0xFFFF) }
                        I64Type, U64Type -> bytecode { it.visitInsn(Opcodes.I2L); bitmask(it, 0xFFFFFFFFL) }
                        F32Type -> bytecode { it.visitInsn(Opcodes.I2L); bitmask(it, 0xFFFFFFFFL); it.visitInsn(Opcodes.L2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.I2L); bitmask(it, 0xFFFFFFFFL); it.visitInsn(Opcodes.L2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    I64Type -> when (to) {
                        U1Type -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.L2I); it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.L2I); it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 0xFFFF) }
                        I32Type, U32Type -> bytecode { it.visitInsn(Opcodes.L2I); }
                        I64Type, U64Type -> sequenceOf()
                        F32Type -> bytecode { it.visitInsn(Opcodes.L2F) }
                        F64Type -> bytecode { it.visitInsn(Opcodes.L2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    U64Type -> when (to) {
                        U1Type -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.L2I); it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.L2I); it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { it.visitInsn(Opcodes.L2I); bitmask(it, 0xFFFF) }
                        I32Type, U32Type -> bytecode { it.visitInsn(Opcodes.L2I); }
                        I64Type, U64Type -> sequenceOf()
                        // double dValue = (double) (value & 0x7fffffffffffffffL);
                        // if (value < 0) {
                        //     dValue += 0x1.0p63;
                        // }
                        // From https://stackoverflow.com/questions/24193788/convert-unsigned-64-bit-decimal-to-java-double
                        F32Type -> bytecode {
                            // start: [long]
                            it.visitInsn(Opcodes.DUP2) // [long, long]
                            it.visitLdcInsn(0x7fffffffffffffffL) // [long, long, mask]
                            it.visitInsn(Opcodes.LAND) // [long, masked long]
                            it.visitInsn(Opcodes.L2F) // [long, float]
                            it.visitInsn(Opcodes.DUP_X2) // [float, long, float]
                            it.visitInsn(Opcodes.POP) // [float, long]
                            val ifNonNegative = Label()
                            it.visitInsn(Opcodes.LCONST_0) // [float, long, 0L]
                            it.visitInsn(Opcodes.LCMP) // [float, int]
                            it.visitJumpInsn(Opcodes.IFGE, ifNonNegative) // jump if int non-negative. [float]
                            it.visitLdcInsn(9223372036854775808f) // 2^63 as a float. [float, 0x1.0p63f]
                            it.visitInsn(Opcodes.FADD) // [float]
                            it.visitLabel(ifNonNegative) // non-negative [float]
                        }
                        F64Type -> bytecode {
                            // start: [long]
                            it.visitInsn(Opcodes.DUP2) // [long, long]
                            it.visitLdcInsn(0x7fffffffffffffffL) // [long, long, mask]
                            it.visitInsn(Opcodes.LAND) // [long, masked long]
                            it.visitInsn(Opcodes.L2D) // [long, double]
                            it.visitInsn(Opcodes.DUP2_X2) // [double, long, double]
                            it.visitInsn(Opcodes.POP2) // [double, long]
                            val ifNonNegative = Label()
                            it.visitInsn(Opcodes.LCONST_0) // [double, long, 0L]
                            it.visitInsn(Opcodes.LCMP) // [double, int]
                            it.visitJumpInsn(Opcodes.IFGE, ifNonNegative) // jump if int non-negative. [double]
                            it.visitLdcInsn(9223372036854775808.0) // 2^63 as a double. [double, 0x1.0p63d]
                            it.visitInsn(Opcodes.DADD) // [double]
                            it.visitLabel(ifNonNegative) // non-negative [double]
                        }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    // Plan for converting float -> ulong:
                    // long fromDouble(double v) {
                    //   if (v <= 0) return 0;
                    //   long oddBit = (long) (v % 2)
                    //   return (((long) (v / 2)) << 1) | oddBit;
                    // }
                    F32Type -> when (to) {
                        U1Type -> bytecode { it.visitInsn(Opcodes.F2I); bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.F2I); it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { it.visitInsn(Opcodes.F2I); bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.F2I); it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { it.visitInsn(Opcodes.F2I); bitmask(it, 0xFFFF) }
                        I32Type -> bytecode { it.visitInsn(Opcodes.F2I) }
                        U32Type -> bytecode { it.visitInsn(Opcodes.F2L); it.visitInsn(Opcodes.L2I) }
                        I64Type -> bytecode { it.visitInsn(Opcodes.F2L) }
                        U64Type -> bytecode {
                            // [v]
                            it.visitInsn(Opcodes.DUP) // [v, v]
                            it.visitInsn(Opcodes.FCONST_0) // [v, v, 0]
                            it.visitInsn(Opcodes.FCMPL) // [v, (v <= 0 or v is NaN) ? (-1 or 0) : 1]
                            val continuing = Label()
                            it.visitJumpInsn(Opcodes.IFGT, continuing) // If it's 1, continue along
                            it.visitInsn(Opcodes.POP) // []
                            it.visitInsn(Opcodes.FCONST_0) // [0]
                            it.visitInsn(Opcodes.FRETURN) // Gone
                            it.visitLabel(continuing) // [v], v is strictly positive
                            it.visitInsn(Opcodes.DUP) // [v, v]
                            it.visitInsn(Opcodes.FCONST_2) // [v, v, 2]
                            it.visitInsn(Opcodes.FREM) // [v, v % 2]
                            it.visitInsn(Opcodes.F2L) // [v, (long) (v % 2)]
                            it.visitInsn(Opcodes.DUP2_X1) // [(long) (v % 2), v, (long) v % 2]
                            it.visitInsn(Opcodes.POP2) // [(long) (v % 2), v]
                            it.visitInsn(Opcodes.FCONST_2) // [(long) (v % 2), v, 2]
                            it.visitInsn(Opcodes.FDIV) // [(long) (v % 2), v / 2]
                            it.visitInsn(Opcodes.F2L) // [(long) (v % 2), (long) (v / 2)]
                            it.visitInsn(Opcodes.ICONST_1) // [(long) (v % 2), (long) (v / 2), 1]
                            it.visitInsn(Opcodes.LSHL) // [(long) (v % 2), ((long) (v / 2)) << 1]
                            it.visitInsn(Opcodes.LOR) // [(long) (v % 2) | (((long) (v / 2)) << 1)]
                            // Done!
                        }
                        F32Type -> sequenceOf()
                        F64Type -> bytecode { it.visitInsn(Opcodes.F2D) }
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    F64Type -> when (to) {
                        U1Type -> bytecode { it.visitInsn(Opcodes.D2I); bitmask(it, 1) }
                        I8Type -> bytecode { it.visitInsn(Opcodes.D2I); it.visitInsn(Opcodes.I2B) }
                        U8Type -> bytecode { it.visitInsn(Opcodes.D2I); bitmask(it, 0xFF) }
                        I16Type -> bytecode { it.visitInsn(Opcodes.D2I); it.visitInsn(Opcodes.I2S) }
                        U16Type, CharType -> bytecode { it.visitInsn(Opcodes.D2I); bitmask(it, 0xFFFF) }
                        I32Type -> bytecode { it.visitInsn(Opcodes.D2I) }
                        U32Type -> bytecode { it.visitInsn(Opcodes.D2L); it.visitInsn(Opcodes.L2I) }
                        I64Type -> bytecode { it.visitInsn(Opcodes.D2L) }
                        U64Type -> bytecode {
                            // [v]
                            it.visitInsn(Opcodes.DUP2) // [v, v]
                            it.visitInsn(Opcodes.DCONST_0) // [v, v, 0]
                            it.visitInsn(Opcodes.DCMPL) // [v, (v <= 0 or v is NaN) ? (-1 or 0) : 1]
                            val continuing = Label()
                            it.visitJumpInsn(Opcodes.IFGT, continuing) // If it's 1, continue along
                            it.visitInsn(Opcodes.POP) // []
                            it.visitInsn(Opcodes.DCONST_0) // [0]
                            it.visitInsn(Opcodes.DRETURN) // Gone
                            it.visitLabel(continuing) // [v], v is strictly positive
                            it.visitInsn(Opcodes.DUP2) // [v, v]
                            it.visitLdcInsn(2.0) // [v, v, 2]
                            it.visitInsn(Opcodes.DREM) // [v, v % 2]
                            it.visitInsn(Opcodes.D2L) // [v, (long) (v % 2)]
                            it.visitInsn(Opcodes.DUP2_X2) // [(long) (v % 2), v, (long) v % 2]
                            it.visitInsn(Opcodes.POP2) // [(long) (v % 2), v]
                            it.visitLdcInsn(2.0) // [(long) (v % 2), v, 2]
                            it.visitInsn(Opcodes.DDIV) // [(long) (v % 2), v / 2]
                            it.visitInsn(Opcodes.D2L) // [(long) (v % 2), (long) (v / 2)]
                            it.visitInsn(Opcodes.ICONST_1) // [(long) (v % 2), (long) (v / 2), 1]
                            it.visitInsn(Opcodes.LSHL) // [(long) (v % 2), ((long) (v / 2)) << 1]
                            it.visitInsn(Opcodes.LOR) // [(long) (v % 2) | (((long) (v / 2)) << 1)]
                            // Done!
                        }
                        F32Type -> bytecode { it.visitInsn(Opcodes.D2F) }
                        F64Type -> sequenceOf()
                        else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                    }
                    else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
                }
            }
            from.isReferenceType && to.isReferenceType -> when {
                from.isSubtype(to) -> sequenceOf()
                to.isSubtype(from) -> sequenceOf(Instruction.Bytecodes(1) {
                    it.visitTypeInsn(Opcodes.CHECKCAST, to.runtimeName)
                })
                else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
            }
            else -> throw IllegalStateException("Unexpected casting type, bug in compiler, please report")
        })

    }


}

// Used privately in this file to help with logic for casting.
// A lot of its methods will not work (they assume 8, 16, 32, 64 bits)
// but that is okay.
private object U1Type: IntType(signed = false, bits = 1)


